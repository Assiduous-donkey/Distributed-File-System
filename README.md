# 分布式文件系统

## 项目规划

### 项目框架

采用客户端-服务器模型，设置目录服务器和文件服务器。目录服务器记录文件的所在服务器，文件服务器存储独立文件，向客户端提供整个文件。客户端请求文件时首先访问目录服务器，获取文件当前的位置，再根据取得的位置访问文件服务器请求对应的文件。每个文件服务器配备一个备份服务器，备份服务器存储它对应的主文件服务器上的文件，使文件有多个副本，且仅与它对应的主文件服务器交互，以确保数据的可用性。主文件服务器与客户端交互，提供基础的文件操作。
<img src="photo/初步框架.png" width = "480" height = "480"/>

### 实现要点

#### 目录服务器

目录服务器需要记录的消息有：

1. 文件路径：文件所在服务器

2. 文件路径：最后修改时间

需要执行的操作有：

1. 创建目录：接收到客户端的创建目录命令时先检查有没有该目录，有则返回“目录已存在”，无则向文件服务器发送创建目录的命令，等待服务器的响应，若文件服务器返回错误信息则将错误信息转发给客户端；若文件服务器返回成功消息则创建目录路径到服务器的键值对。（应该考虑超时机制——服务器失效）

2. 创建文件：接收到客户端的命令之后检查有无该文件，有则返回“文件已存在”，否则向文件服务器发送创建文件的命令，等待服务器响应，若文件服务器返回错误信息则将错误信息转发给客户端；若文件服务器返回成功消息则创建文件路径到服务器的键值对。（应该考虑超时机制——服务器失效）

3. 读文件：接收到客户端的命令之后检查有无该文件，若文件不存在则返回“文件不存在”，否则返回给客户端文件对应的服务器地址以及该文件的最后修改时间

4. 写文件：接收到客户端的命令之后检查有无该文件，若文件不存在则返回“文件不存在”，否则返回给客户端文件对应的服务器地址以及该文件的最后修改时间

5. 删除文件：接收到客户端的命令之后检查有无该文件，若文件不存在则返回“文件不存在”，否则向文件服务器发送删除文件的命令，等待服务器响应，若文件服务器返回错误信息则将错误信息转发给客户端；若文件服务器返回成功消息则删除该文件对应的键值对。（应该考虑超时机制——服务器失效）

6. 删除目录：接收到客户端的命令之后检查有无该目录，若文件不存在则返回“目录不存在”，否则向文件服务器发送删除目录的命令，等待服务器响应，若文件服务器返回错误信息则将错误信息转发给客户端；若文件服务器返回成功消息则删除该目录对应的键值对。（应该考虑超时机制——服务器失效）

#### 客户端

客户端初始时处于**根目录**，使用命令可切换到其他目录下，所以**客户端要时刻记录自己当前所处的目录**。
客户端添加本地缓存，若本地缓存的文件已经是服务器上的最新文件，则没必要再下载。
因此本地缓存要保存文件路径对应的最后修改时间。
最好建一个目录专门缓存这些文件，文件名修改为文件在文件系统中的路径，其中“/”用下划线“_”代替

1. 创建目录：发送命令给目录服务器，等待目录服务器响应。

2. 创建文件：发送命令给目录服务器，等待目录服务器响应。

3. 读文件：发送命令给目录服务器，等待目录服务器响应。接收到返回的信息后，查看本地缓存，若该文件有本地缓存且缓存的最后修改时间与目录服务器返回的时间一致，则直接读取本地缓存即可，不必再向文件服务器发请求；若有缓存但目录服务器返回的最后修改时间比缓存的修改时间新，或者本地没缓存，则向文件服务器发送请求请求获取文件。

4. 写文件：发送命令(write)给目录服务器，等待目录服务器响应。接收到正确的返回消息后，向文件服务器发送写文件请求，若成功则可下载到要写的文件以及写锁的钥匙，缓存下来。在本地写好文件后向文件服务器发送命令(upload)上传文件，发送upload要带上解开写锁的钥匙（这个钥匙用于区别不同用户的提交操作）。

5. 删除文件：发送命令给目录服务器，等待目录服务器的响应。

6. 删除目录：发送命令给目录服务器，等待目录服务器的响应（若目录中有文件，删除其中所有文件）

#### 服务端

服务器端除了要存储文件外还要实现对文件加锁的功能。
加锁功能需要缓存文件的写锁对应的钥匙。

1. 创建目录：接收到目录服务器的请求后在本地创建目录，返回成功或失败消息给目录服务器。

2. 创建文件：接收到目录服务器的请求后在本地创建目录，返回成功或失败消息给目录服务器。

3. 读文件：接收客户端发送的请求，为文件加读锁然后将文件传输给客户端。

4. 写文件：接收客户端发送的请求，收到write命令时，若文件本身有写锁，则拒绝客户端的请求；若无则加写锁，然后发送文件给客户端并生成一个写锁的钥匙发送给客户端。收到upload命令后匹配客户端的钥匙是否可以打开写锁，不可则返回错误信息，可以则更新文件，返回成功信息。然后发送文件的最后修改时间给目录服务器，最后释放锁。

5. 删除文件：删除本地文件后返回信息给目录服务器

6. 删除目录：删除目录后返回信息给目录服务器

#### 锁机制

1. 读锁：对于读操作，设计思路是可以多用户并行读，由于os.Open可以同时打开相同文件，所以并行读时好像也不需要用到读锁。但需考虑在服务器更新文件时有用户发起读请求，这时要阻塞用户。或者服务器要更新文件时，若有用户正在读，则等待用户读完（先设计为读者优先）。所以读锁是加在服务器读取文件的时候。

2. 写锁：对于写操作，需要两个步骤。服务器接受到write请求时加写锁并生成钥匙返回给客户端，客户端upload的时候再携带钥匙来打开写锁更新文件，然后锁被释放。写操作需要互斥，一个文件只允许有一把锁，可以设置超时机制，若超时仍未收到upload则释放锁。

#### 通信方式

节点之间都采用**RPC**方式通信：客户端——目录服务器、目录服务器——文件服务器、客户端——文件服务器、文件服务器——备份服务器

#### 一致性

#### 容错

主服务器失效时由备份服务器顶替成为主服务器，顶替过程中不可被用户访问。失效服务器重启后成为备份服务器，与主文件服务器进行数据同步，这一过程也不可被用户访问。
问题在于怎么判断主文件服务器失效。一个简单的方法是若对于该服务器的连续N（一个阈值）个请求都是无效的，则认为该服务器失效，为此可以在目录服务器上添加记录，记录该服务器上连续的无效请求次数。

#### 安全性

1. 目录服务器单点失效，可以为目录服务器也提供一个备份服务器。

2. 目录服务器上的记录可以存缓存和磁盘，因此可以采用Redis数据库，Redis运行在内存中但可以将数据持久化到磁盘上。存到磁盘上可以防止掉电丢失等意外情况。

#### 文件存储

采用目录结构，遵从以下规则：

1. 同一目录下不能有同名文件

2. 不能有同名目录

#### 交互方式

客户端在控制台运行客户端程序之后通过输入指令来执行操作，命令格式如下：

1. mkdir 目录名 ———— 创建目录

2. cd 目录名    ———— 切换目录

3. cd ..        ———— 返回上一级

4. create 文件名(可包含路径) ———— 新建文件

5. write 文件名(包含路径) ———— 写文件，实则是下载

6. upload 文件名(可包含路径) ———— 上传文件 （这是write的后续操作）

7. read 文件名(可包含路径) ———— 下载文件

8. rm 文件名(可包含路径) ———— 删除文件

9. rm-all 目录名 ———— 删除整个目录包括里面所有文件
